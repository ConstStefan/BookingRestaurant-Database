-- Generated by Oracle SQL Developer Data Modeler 23.1.0.087.0806
--   at:        2024-05-27 00:33:03 EEST
--   site:      Oracle Database 12c
--   type:      Oracle Database 12c



-- predefined type, no DDL - MDSYS.SDO_GEOMETRY

-- predefined type, no DDL - XMLTYPE

create or replace PACKAGE customers_pkg AS
  PROCEDURE insert_customer(p_customer_id IN INTEGER, p_nume IN VARCHAR2, p_phone IN VARCHAR2, p_email IN VARCHAR2);
  PROCEDURE update_customer(p_customer_id IN INTEGER, p_nume IN VARCHAR2, p_phone IN VARCHAR2, p_email IN VARCHAR2);
  PROCEDURE delete_customer(p_customer_id IN INTEGER);
END customers_pkg;
/

create or replace PACKAGE reservations_pkg AS
  PROCEDURE insert_reservation(p_reservation_id IN INTEGER, p_reservation_date IN TIMESTAMP, p_number_of_guests IN INTEGER, p_status IN VARCHAR2, p_table_id IN INTEGER, p_customer_id IN INTEGER);
  PROCEDURE update_reservation(p_reservation_id IN INTEGER, p_reservation_date IN TIMESTAMP, p_number_of_guests IN INTEGER, p_status IN VARCHAR2, p_table_id IN INTEGER, p_customer_id IN INTEGER);
  PROCEDURE delete_reservation(p_reservation_id IN INTEGER);
END reservations_pkg;
/

create or replace PACKAGE restaurantmanagers_pkg AS
  PROCEDURE insert_manager(p_manager_id IN INTEGER, p_nume IN VARCHAR2, p_phone IN VARCHAR2, p_email IN VARCHAR2, p_restaurant_id IN INTEGER);
  PROCEDURE update_manager(p_manager_id IN INTEGER, p_nume IN VARCHAR2, p_phone IN VARCHAR2, p_email IN VARCHAR2, p_restaurant_id IN INTEGER);
  PROCEDURE delete_manager(p_manager_id IN INTEGER);
END restaurantmanagers_pkg;
/

create or replace PACKAGE restaurants_pkg AS
  PROCEDURE insert_restaurant(p_restaurant_id IN INTEGER, p_nume IN VARCHAR2, p_location IN VARCHAR2, p_capacity IN INTEGER);
  PROCEDURE update_restaurant(p_restaurant_id IN INTEGER, p_nume IN VARCHAR2, p_location IN VARCHAR2, p_capacity IN INTEGER);
  PROCEDURE delete_restaurant(p_restaurant_id IN INTEGER);
END restaurants_pkg;
/

create or replace PACKAGE tabless_pkg AS
  PROCEDURE insert_table(p_table_id IN INTEGER, p_numar IN INTEGER, p_seating_capacity IN INTEGER, p_restaurant_id IN INTEGER);
  PROCEDURE update_table(p_table_id IN INTEGER, p_numar IN INTEGER, p_seating_capacity IN INTEGER, p_restaurant_id IN INTEGER);
  PROCEDURE delete_table(p_table_id IN INTEGER);
END tabless_pkg;
/

CREATE TABLE reservations (
    reservation_id   INTEGER NOT NULL,
    reservation_date TIMESTAMP NOT NULL,
    number_of_guests INTEGER NOT NULL,
    status           VARCHAR2(10) NOT NULL,
    table_id         INTEGER NOT NULL,
    customer_id      INTEGER NOT NULL
)
LOGGING;

ALTER TABLE reservations ADD CONSTRAINT reservations_pk PRIMARY KEY ( reservation_id );

CREATE OR REPLACE NONEDITIONABLE FUNCTION get_total_confirmed_reservation RETURN INTEGER IS
    v_total_reservations INTEGER;
BEGIN
    SELECT
        COUNT(*)
    INTO v_total_reservations
    FROM
        reservations
    WHERE
        status = 'Confirmed';

    RETURN v_total_reservations;
END get_total_confirmed_reservation;
/

CREATE TABLE customers (
    customer_id INTEGER NOT NULL,
    nume        VARCHAR2(100) NOT NULL,
    phone       VARCHAR2(15) NOT NULL,
    email       VARCHAR2(50) NOT NULL
)
LOGGING;

ALTER TABLE customers ADD CONSTRAINT customers_pk PRIMARY KEY ( customer_id );

ALTER TABLE customers ADD CONSTRAINT customers_email_un UNIQUE ( email );

CREATE TABLE tabless (
    table_id         INTEGER NOT NULL,
    numar            INTEGER NOT NULL,
    seating_capacity INTEGER NOT NULL,
    restaurant_id    INTEGER NOT NULL
)
LOGGING;

ALTER TABLE tabless ADD CONSTRAINT tables_pk PRIMARY KEY ( table_id );

CREATE OR REPLACE NONEDITIONABLE FUNCTION get_total_customers_and_guests_for_restaurant (
    p_restaurant_id IN INTEGER
) RETURN INTEGER IS
    v_total_customers INTEGER;
    v_total_guests    INTEGER;
    v_total_count     INTEGER;
BEGIN
  -- Calcularea numarului total de clienti pentru un anumit restaurant
    SELECT
        COUNT(DISTINCT c.customer_id)
    INTO v_total_customers
    FROM
             customers c
        JOIN reservations r ON c.customer_id = r.customer_id
        JOIN tabless      t ON r.table_id = t.table_id
    WHERE
        t.restaurant_id = p_restaurant_id;

  -- Calcularea numarului total de invitati pentru un anumit restaurant
    SELECT
        SUM(r.number_of_guests)
    INTO v_total_guests
    FROM
             reservations r
        JOIN tabless t ON r.table_id = t.table_id
    WHERE
        t.restaurant_id = p_restaurant_id;

    v_total_count := v_total_customers + v_total_guests;
    RETURN v_total_count;
END get_total_customers_and_guests_for_restaurant;
/

create or replace NONEDITIONABLE PROCEDURE delete_customer_and_reservations(p_customer_id IN INTEGER) IS
BEGIN
  DELETE FROM reservations WHERE customer_id = p_customer_id;
  DELETE FROM customers WHERE customer_id = p_customer_id;
  COMMIT;
END delete_customer_and_reservations;
/

create or replace PROCEDURE ListReservationsForCustomer(
    p_customer_id IN INTEGER
) IS
    --  cursor pentru a selecta rezervarile clientului
    CURSOR reservations_cursor IS
        SELECT reservation_id, reservation_date, number_of_guests, status, table_id
        FROM reservations
        WHERE customer_id = p_customer_id;

    -- variabile
    v_reservation_id reservations.reservation_id%TYPE;
    v_reservation_date reservations.reservation_date%TYPE;
    v_number_of_guests reservations.number_of_guests%TYPE;
    v_status reservations.status%TYPE;
    v_table_id reservations.table_id%TYPE;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Rezervarile pentru clientul cu ID ' || p_customer_id || ':');


    OPEN reservations_cursor;


    LOOP
        FETCH reservations_cursor INTO v_reservation_id, v_reservation_date, v_number_of_guests, v_status, v_table_id;
        EXIT WHEN reservations_cursor%NOTFOUND;

        -- Afi?area detalii
        DBMS_OUTPUT.PUT_LINE('Reservation ID: ' || v_reservation_id);
        DBMS_OUTPUT.PUT_LINE('Reservation Date: ' || v_reservation_date);
        DBMS_OUTPUT.PUT_LINE('Number of Guests: ' || v_number_of_guests);
        DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);
        DBMS_OUTPUT.PUT_LINE('Table ID: ' || v_table_id);
        DBMS_OUTPUT.PUT_LINE('----------------------------');
    END LOOP;


    CLOSE reservations_cursor;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Eroare la listarea rezervarilor: ' || SQLERRM);
END;
/

CREATE TABLE restaurants (
    restaurant_id INTEGER NOT NULL,
    nume          VARCHAR2(100) NOT NULL,
    location      VARCHAR2(100) NOT NULL,
    capacity      INTEGER NOT NULL
)
LOGGING;

ALTER TABLE restaurants ADD CONSTRAINT restaurants_pk PRIMARY KEY ( restaurant_id );

create or replace NONEDITIONABLE PROCEDURE update_restaurant_capacity(p_restaurant_id IN INTEGER, p_new_capacity IN INTEGER) IS
BEGIN
  UPDATE restaurants
  SET capacity = p_new_capacity
  WHERE restaurant_id = p_restaurant_id;
  COMMIT;
END update_restaurant_capacity;
/

create or replace NONEDITIONABLE PROCEDURE UpdateReservation(
    p_reservation_id INT,
    p_new_table_id INT,
    p_new_reservation_date TIMESTAMP,
    p_new_number_of_guests INT,
    p_new_status VARCHAR2
) AS
BEGIN
    IF p_new_status = 'Cancelled' THEN
        DELETE FROM reservations
        WHERE reservation_id = p_reservation_id;
        DBMS_OUTPUT.PUT_LINE('Rezervare anulata si stearsa cu succes.');
    ELSE
        UPDATE reservations
        SET table_id = p_new_table_id,
            reservation_date = p_new_reservation_date,
            number_of_guests = p_new_number_of_guests,
            status = p_new_status
        WHERE reservation_id = p_reservation_id;
        DBMS_OUTPUT.PUT_LINE('Rezervare actualizata cu succes.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Eroare la actualizarea rezervarii: ' || SQLERRM);
END;
/

CREATE TABLE restaurantmanagers (
    manager_id    INTEGER NOT NULL,
    nume          VARCHAR2(100) NOT NULL,
    phone         VARCHAR2(15) NOT NULL,
    email         VARCHAR2(50) NOT NULL,
    restaurant_id INTEGER NOT NULL
)
LOGGING;

ALTER TABLE restaurantmanagers ADD CONSTRAINT restaurantmanagers_pk PRIMARY KEY ( manager_id );

ALTER TABLE restaurantmanagers ADD CONSTRAINT restaurantmanagers__un UNIQUE ( restaurant_id );

ALTER TABLE restaurantmanagers ADD CONSTRAINT restaurantmanagers_email_un UNIQUE ( email );

ALTER TABLE reservations
    ADD CONSTRAINT reservations_customers_fk FOREIGN KEY ( customer_id )
        REFERENCES customers ( customer_id )
    NOT DEFERRABLE;

ALTER TABLE reservations
    ADD CONSTRAINT reservations_tables_fk FOREIGN KEY ( table_id )
        REFERENCES tabless ( table_id )
    NOT DEFERRABLE;

ALTER TABLE restaurantmanagers
    ADD CONSTRAINT restmng_restaurants_fk FOREIGN KEY ( restaurant_id )
        REFERENCES restaurants ( restaurant_id )
    NOT DEFERRABLE;

ALTER TABLE tabless
    ADD CONSTRAINT tables_restaurants_fk FOREIGN KEY ( restaurant_id )
        REFERENCES restaurants ( restaurant_id )
    NOT DEFERRABLE;

CREATE OR REPLACE TRIGGER trg_check_restaurant_capacity 
    BEFORE INSERT OR UPDATE ON tabless 
    FOR EACH ROW 
DECLARE
  v_total_seating_capacity INTEGER;
  v_restaurant_capacity INTEGER;
BEGIN
  -- Obtine capacitatea totala a restaurantului
  SELECT capacity INTO v_restaurant_capacity
  FROM restaurants
  WHERE restaurant_id = :NEW.restaurant_id;

  -- Calculeaza suma capacita?ilor meselor existente ?i noua masa
  SELECT SUM(seating_capacity) + :NEW.seating_capacity INTO v_total_seating_capacity
  FROM tabless
  WHERE restaurant_id = :NEW.restaurant_id
  AND (table_id != :OLD.table_id OR :OLD.table_id IS NULL);

  -- Verific dac suma depaseste capacitatea restaurantului
  IF v_total_seating_capacity > v_restaurant_capacity THEN
    RAISE_APPLICATION_ERROR(-20004, 'The total seating capacity exceeds the capacity of the restaurant.');
  END IF;
  END trg_check_restaurant_capacity; 
/

CREATE OR REPLACE TRIGGER trg_check_seating_capacity 
    BEFORE INSERT OR UPDATE ON reservations 
    FOR EACH ROW 
DECLARE
  v_seating_capacity INTEGER;
  v_total_guests INTEGER;
BEGIN
  SELECT seating_capacity INTO v_seating_capacity
  FROM tabless
  WHERE table_id = :NEW.table_id;

  -- Calculam numarul total de oaspeti (number_of_guests + 1 pentru client)
  v_total_guests := :NEW.number_of_guests + 1;

  -- Verificam daca numarul total de oaspeti depaseste capacitatea mesei
  IF v_total_guests > v_seating_capacity THEN
    RAISE_APPLICATION_ERROR(-20001, 'The number of guests plus the customer exceeds the seating capacity of the table.');
  END IF;
END; 
/

CREATE OR REPLACE TRIGGER trg_delete_customer 
    AFTER DELETE ON customers 
    FOR EACH ROW 
DECLARE
  CURSOR reservations_cursor IS
    SELECT reservation_id
    FROM reservations 
    WHERE customer_id = :OLD.customer_id;

  v_reservation_id reservations.reservation_id%TYPE;
BEGIN
  -- Iteram prin toate rezervarile asociate clientului care a fost sters
  OPEN reservations_cursor;
  LOOP
    FETCH reservations_cursor INTO v_reservation_id;
    EXIT WHEN reservations_cursor%NOTFOUND;

    DELETE FROM reservations WHERE reservation_id = v_reservation_id;
  END LOOP;
  CLOSE reservations_cursor;
END; 
/

CREATE OR REPLACE TRIGGER trg_prevent_multiple_managers 
    BEFORE INSERT OR UPDATE ON restaurantmanagers 
    FOR EACH ROW 
DECLARE
  v_count INTEGER;
BEGIN
  -- Verificam dac? exista deja un manager pentru restaurantul specificat
  IF :NEW.restaurant_id IS NOT NULL THEN
    SELECT COUNT(*)
    INTO v_count
    FROM restaurantmanagers
    WHERE restaurant_id = :NEW.restaurant_id
    AND (:OLD.manager_id IS NULL OR manager_id != :OLD.manager_id);

    IF v_count > 0 THEN
      RAISE_APPLICATION_ERROR(-20002, 'There is already a manager assigned to this restaurant.');
    END IF;
  END IF;

  -- Verificam dac? restaurantul exista
  IF :NEW.restaurant_id IS NOT NULL THEN
    SELECT COUNT(*)
    INTO v_count
    FROM restaurants
    WHERE restaurant_id = :NEW.restaurant_id;

    IF v_count = 0 THEN
      RAISE_APPLICATION_ERROR(-20003, 'The specified restaurant does not exist.');
    END IF;
  END IF;
END trg_prevent_multiple_managers; 
/

CREATE OR REPLACE PACKAGE BODY customers_pkg AS

    PROCEDURE insert_customer (
        p_customer_id IN INTEGER,
        p_nume        IN VARCHAR2,
        p_phone       IN VARCHAR2,
        p_email       IN VARCHAR2
    ) IS
    BEGIN
        INSERT INTO customers (
            customer_id,
            nume,
            phone,
            email
        ) VALUES (
            p_customer_id,
            p_nume,
            p_phone,
            p_email
        );

    END insert_customer;

    PROCEDURE update_customer (
        p_customer_id IN INTEGER,
        p_nume        IN VARCHAR2,
        p_phone       IN VARCHAR2,
        p_email       IN VARCHAR2
    ) IS
    BEGIN
        UPDATE customers
        SET
            nume = p_nume,
            phone = p_phone,
            email = p_email
        WHERE
            customer_id = p_customer_id;

    END update_customer;

    PROCEDURE delete_customer (
        p_customer_id IN INTEGER
    ) IS
    BEGIN
        DELETE FROM customers
        WHERE
            customer_id = p_customer_id;

    END delete_customer;

END customers_pkg;
/

CREATE OR REPLACE PACKAGE BODY reservations_pkg AS

    PROCEDURE insert_reservation (
        p_reservation_id   IN INTEGER,
        p_reservation_date IN TIMESTAMP,
        p_number_of_guests IN INTEGER,
        p_status           IN VARCHAR2,
        p_table_id         IN INTEGER,
        p_customer_id      IN INTEGER
    ) IS
    BEGIN
        INSERT INTO reservations (
            reservation_id,
            reservation_date,
            number_of_guests,
            status,
            table_id,
            customer_id
        ) VALUES (
            p_reservation_id,
            p_reservation_date,
            p_number_of_guests,
            p_status,
            p_table_id,
            p_customer_id
        );

    END insert_reservation;

    PROCEDURE update_reservation (
        p_reservation_id   IN INTEGER,
        p_reservation_date IN TIMESTAMP,
        p_number_of_guests IN INTEGER,
        p_status           IN VARCHAR2,
        p_table_id         IN INTEGER,
        p_customer_id      IN INTEGER
    ) IS
    BEGIN
        UPDATE reservations
        SET
            reservation_date = p_reservation_date,
            number_of_guests = p_number_of_guests,
            status = p_status,
            table_id = p_table_id,
            customer_id = p_customer_id
        WHERE
            reservation_id = p_reservation_id;

    END update_reservation;

    PROCEDURE delete_reservation (
        p_reservation_id IN INTEGER
    ) IS
    BEGIN
        DELETE FROM reservations
        WHERE
            reservation_id = p_reservation_id;

    END delete_reservation;

END reservations_pkg;
/

CREATE OR REPLACE PACKAGE BODY restaurantmanagers_pkg AS

    PROCEDURE insert_manager (
        p_manager_id    IN INTEGER,
        p_nume          IN VARCHAR2,
        p_phone         IN VARCHAR2,
        p_email         IN VARCHAR2,
        p_restaurant_id IN INTEGER
    ) IS
    BEGIN
        INSERT INTO restaurantmanagers (
            manager_id,
            nume,
            phone,
            email,
            restaurant_id
        ) VALUES (
            p_manager_id,
            p_nume,
            p_phone,
            p_email,
            p_restaurant_id
        );

    END insert_manager;

    PROCEDURE update_manager (
        p_manager_id    IN INTEGER,
        p_nume          IN VARCHAR2,
        p_phone         IN VARCHAR2,
        p_email         IN VARCHAR2,
        p_restaurant_id IN INTEGER
    ) IS
    BEGIN
        UPDATE restaurantmanagers
        SET
            nume = p_nume,
            phone = p_phone,
            email = p_email,
            restaurant_id = p_restaurant_id
        WHERE
            manager_id = p_manager_id;

    END update_manager;

    PROCEDURE delete_manager (
        p_manager_id IN INTEGER
    ) IS
    BEGIN
        DELETE FROM restaurantmanagers
        WHERE
            manager_id = p_manager_id;

    END delete_manager;

END restaurantmanagers_pkg;
/

CREATE OR REPLACE NONEDITIONABLE PACKAGE BODY restaurants_pkg AS

    PROCEDURE insert_restaurant (
        p_restaurant_id IN INTEGER,
        p_nume          IN VARCHAR2,
        p_location      IN VARCHAR2,
        p_capacity      IN INTEGER
    ) IS
    BEGIN
        INSERT INTO restaurants (
            restaurant_id,
            nume,
            location,
            capacity
        ) VALUES (
            p_restaurant_id,
            p_nume,
            p_location,
            p_capacity
        );

    END insert_restaurant;

    PROCEDURE update_restaurant (
        p_restaurant_id IN INTEGER,
        p_nume          IN VARCHAR2,
        p_location      IN VARCHAR2,
        p_capacity      IN INTEGER
    ) IS
    BEGIN
        UPDATE restaurants
        SET
            nume = p_nume,
            location = p_location,
            capacity = p_capacity
        WHERE
            restaurant_id = p_restaurant_id;

    END update_restaurant;

    PROCEDURE delete_restaurant (
        p_restaurant_id IN INTEGER
    ) IS
    BEGIN
        DELETE FROM restaurants
        WHERE
            restaurant_id = p_restaurant_id;

    END delete_restaurant;

END restaurants_pkg;
/

CREATE OR REPLACE PACKAGE BODY tabless_pkg AS

    PROCEDURE insert_table (
        p_table_id         IN INTEGER,
        p_numar            IN INTEGER,
        p_seating_capacity IN INTEGER,
        p_restaurant_id    IN INTEGER
    ) IS
    BEGIN
        INSERT INTO tabless (
            table_id,
            numar,
            seating_capacity,
            restaurant_id
        ) VALUES (
            p_table_id,
            p_numar,
            p_seating_capacity,
            p_restaurant_id
        );

    END insert_table;

    PROCEDURE update_table (
        p_table_id         IN INTEGER,
        p_numar            IN INTEGER,
        p_seating_capacity IN INTEGER,
        p_restaurant_id    IN INTEGER
    ) IS
    BEGIN
        UPDATE tabless
        SET
            numar = p_numar,
            seating_capacity = p_seating_capacity,
            restaurant_id = p_restaurant_id
        WHERE
            table_id = p_table_id;

    END update_table;

    PROCEDURE delete_table (
        p_table_id IN INTEGER
    ) IS
    BEGIN
        DELETE FROM tabless
        WHERE
            table_id = p_table_id;

    END delete_table;

END tabless_pkg;
/



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             5
-- CREATE INDEX                             0
-- ALTER TABLE                             12
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           5
-- CREATE PACKAGE BODY                      5
-- CREATE PROCEDURE                         4
-- CREATE FUNCTION                          2
-- CREATE TRIGGER                           4
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          0
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- TSDP POLICY                              0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
